#include "editor\menuBar.h"
#include <iostream> // just for debugging, cam remove later

void MenuBar::initialize(HINSTANCE hInstance, GoMenu &goMenu, Engine* engine)
{
	_hInstance = hInstance;
	_engine = engine;
	_goMenu = &goMenu;
	_gamePlaying = false;
	_goMenu->setGamePlaying(_gamePlaying);
}

LRESULT MenuBar::processMsg(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	int wmId, wmEvent;

	switch (message)
	{
	case WM_COMMAND:
		wmId    = LOWORD(wParam); // the low word of wparam is the ID of the command
		wmEvent = HIWORD(wParam);
		
		// Parse the menu selections:
		switch (wmId)
		{
		case IDM_ABOUT:
			DialogBox(_hInstance, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);
			break;
		case IDM_EXIT:
			DestroyWindow(hWnd);
			break;

		// TO DO: There seems to be some problem with VS / WinAPI menus. This is meant to be auto-generated by WinAPI. No idea why it's not working
		case ID_CONTROL_PLAY:
			playStop();
			break;
			

		default:
			return DefWindowProc(hWnd, message, wParam, lParam);
		}
		break;


	case WM_DESTROY:
		PostQuitMessage(0);
		break;
	default:
		return DefWindowProc(hWnd, message, wParam, lParam);
	}
	return 0;
}

// Getter for finding out if cuyrrently in "play mode" or not
bool MenuBar::gamePlaying()
{
	return _gamePlaying;
}

// Message handler for about box.
INT_PTR CALLBACK MenuBar::About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	UNREFERENCED_PARAMETER(lParam);
	switch (message)
	{
	case WM_INITDIALOG:
		return (INT_PTR)TRUE;

	case WM_COMMAND:
		if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)
		{
			EndDialog(hDlg, LOWORD(wParam));
			return (INT_PTR)TRUE;
		}
		break;
	}
	return (INT_PTR)FALSE;
}

// Control menu
void MenuBar::playStop()
{
	// Reset game to init state
	_engine->initGame();

	// Toggle Game Playing
	_gamePlaying = !_gamePlaying;
	_goMenu->setGamePlaying(_gamePlaying);
}